---
title: MySQL练习 - 场景模拟初级篇(持续更新)
thumbnail: 
date: 2021-10-6 22:33:36
toc: true
tags:
    - MySQL练习题
categories:
    - [SQL,MySQL]
---

> 摘要
MySQL练习题，基于不同的场景模拟进一步加强MySQl知识点练习～
<!-- more -->

## MySQL练习 - 场景模拟初级篇

</br>

### 薪水涨幅升序

</br>

**[题目]**

现在有两个表：

- **雇员表**：记录了雇员基本信息，字段包括：雇员编号、出生日期、姓名、性别、雇用日期
- **薪水表**：记录了雇员的**薪水金额**以及**签订周期**，字段包括：雇员编号、薪水、起始日期、结束日期
- 两张表通过雇员编号进行连结

现在需要查找当前所有雇员入职以来的薪水涨幅，给出雇员编号以及其对应的薪水涨幅，并按照薪水涨幅进行升序

注意：薪水表中最大结束日期为2004-01-01，说明结束日期在此之前的均表示为已离职员工



```mysql
#建雇员表

create table employees( 
    id int not null comment "雇员编号", 
    birthday date comment "出生日 期", 
    name varchar(64) comment "姓名", 
    sex varchar(64) comment "性别", 
    employ_date date comment " 雇用日期");

#查看表
desc employees;
+-------------+-------------+------+-----+---------+-------+
| Field       | Type        | Null | Key | Default | Extra |
+-------------+-------------+------+-----+---------+-------+
| id          | int(11)     | NO   |     | NULL    |       |
| birthday    | date        | YES  |     | NULL    |       |
| name        | varchar(64) | YES  |     | NULL    |       |
| sex         | varchar(64) | YES  |     | NULL    |       |
| employ_date | date        | YES  |     | NULL    |       |
+-------------+-------------+------+-----+---------+-------+

#插入数据
insert into employees(id,birthday,name,sex,employ_date) 
values 
(10002,"1976-09-09","周周","女","2001-08-02"),
(10005,"1978-09-09","小明","男","2001-09-09"),
(10006,"1979-08-29","西西","女","2001-08-02")
;

#查看数据
select * from employees;
+-------+------------+--------+------+-------------+
| id    | birthday   | name   | sex  | employ_date |
+-------+------------+--------+------+-------------+
| 10002 | 1976-09-09 | 周周   | 女   | 2001-08-02  |
| 10005 | 1978-09-09 | 小明   | 男   | 2001-09-09  |
| 10006 | 1979-08-29 | 西西   | 女   | 2001-08-02  |
+-------+------------+--------+------+-------------+


#建薪水表
create table salary(
    id int not null comment "雇员编号",
    pay int comment "薪资",
    start_date date comment "起始日期",
    finish_date date comment "结束日期");

#查看表
desc salary;
+-------------+---------+------+-----+---------+-------+
| Field       | Type    | Null | Key | Default | Extra |
+-------------+---------+------+-----+---------+-------+
| id          | int(11) | NO   |     | NULL    |       |
| pay         | int(11) | YES  |     | NULL    |       |
| start_date  | date    | YES  |     | NULL    |       |
| finish_date | date    | YES  |     | NULL    |       |
+-------------+---------+------+-----+---------+-------+

#插入数据
insert into salary(id,pay,start_date,finish_date) 
values 
(10002,72527,"2001-08-02","2003-01-01"),
(10002,75432,"2003-01-01","2004-01-01"),
(10005,94692,"2001-09-09","2003-01-01"),
(10006,43311,"2001-08-02","2004-01-01")
;

#查看数据
select * from salary;
+-------+-------+------------+-------------+
| id    | pay   | start_date | finish_date |
+-------+-------+------------+-------------+
| 10002 | 72527 | 2001-08-02 | 2003-01-01  |
| 10002 | 75432 | 2003-01-01 | 2004-01-01  |
| 10005 | 94692 | 2001-09-09 | 2003-01-01  |
| 10006 | 43311 | 2001-08-02 | 2004-01-01  |
+-------+-------+------------+-------------+

```

</br>

**[思路]**

- **读题**：查找**当前所有雇员**入职以来的**薪水涨幅**，给出雇员编号以及对应的薪水涨幅，并按照薪水涨幅进行升序
- **解题**：
  - 输出为：雇员编号、薪水涨幅，且按照薪水涨幅进行升序排列
  - 限定条件为：当前雇员，即结束日期为表中最大日期2004 - 01 - 01
  - 薪水涨幅 = 当前薪水 - 入职薪水 ，根据最终输出要求，先分别找出雇员编号+当前薪水作为临时表a，在找出雇员编号+入职薪水作为临时表b，最后将临时表a和临时表b进行join方能运算出结果



```mysql

select a.id,(a.pay - b.pay) as "薪水涨幅" 
from 
(select id,pay from salary where finish_date = "2004-01-01") as a 
join 
(select e.id,s.pay from 
 employees as e 
 join salary as s 
 on e.id = s.id 
 where e.employ_date = s.start_date 
 and 
 e.id in 
 (select id from salary where finish_date = "2004-01-01")) as b 
 on a.id = b.id 
 order by "薪水涨幅";
 
 
+-------+--------------+
| id    | 薪水涨幅     |
+-------+--------------+
| 10002 |         2905 |
| 10006 |            0 |
+-------+--------------+

```

</br>

### 比前一天高的数据
</br>

**[题目]**

"日销"表记录了某公司每天的营业额，字段有：id，日期，营业额(万元)

现在需要找出所有比前一天(昨天)营业额更高的数据

```mysql
#创建表

create table daysale(
    id int not null,
    saledate date comment "日期",
    turnover int comment "营业额(万元)");
    
#查看表
desc daysale;
+----------+---------+------+-----+---------+-------+
| Field    | Type    | Null | Key | Default | Extra |
+----------+---------+------+-----+---------+-------+
| id       | int(11) | NO   |     | NULL    |       |
| saledate | date    | YES  |     | NULL    |       |
| turnover | int(11) | YES  |     | NULL    |       |
+----------+---------+------+-----+---------+-------+

#插入数据
insert into daysale(id,saledate,turnover) 
values 
(1,"2019-01-01",97),
(2,"2019-01-02",87),
(3,"2019-01-03",88),
(4,"2019-01-04",98),
(5,"2019-01-05",100),
(6,"2019-01-06",80),
(7,"2019-01-07",77),
(8,"2019-01-08",92);

#查看数据
select * from daysale;
+----+------------+----------+
| id | saledate   | turnover |
+----+------------+----------+
|  1 | 2019-01-01 |       97 |
|  2 | 2019-01-02 |       87 |
|  3 | 2019-01-03 |       88 |
|  4 | 2019-01-04 |       98 |
|  5 | 2019-01-05 |      100 |
|  6 | 2019-01-06 |       80 |
|  7 | 2019-01-07 |       77 |
|  8 | 2019-01-08 |       92 |
+----+------------+----------+
```

</br>

**[思路]**

- 读题：找出所有**营业额**比**前一天(昨天)**营业额更高的数据
- 解题：
  - 比较同一个表内不同行的内容需要自join，连结条件为日期差为1天
    - 日期比较方式1：datediff(日期1,日期2) ，即日期1 - 日期2的天数差
    - 日期比较方式2：timestampdiff(day/hour/second,日期1,日期2)，即日期2 - 日期1的差，与上面相反
  - 结果限定条件为：营业额比前一天的高



```mysql
#datediff

select b.* 
from daysale as a join daysale as b 
on datediff(b.saledate,a.saledate) = 1
where b.turnover > a.turnover;

+----+------------+----------+
| id | saledate   | turnover |
+----+------------+----------+
|  3 | 2019-01-03 |       88 |
|  4 | 2019-01-04 |       98 |
|  5 | 2019-01-05 |      100 |
|  8 | 2019-01-08 |       92 |
+----+------------+----------+

#timestempdiff
select b.* 
from daysale as a join daysale as b 
on timestampdiff(day,a.saledate,b.saledate) = 1
where b.turnover > a.turnover;

+----+------------+----------+
| id | saledate   | turnover |
+----+------------+----------+
|  3 | 2019-01-03 |       88 |
|  4 | 2019-01-04 |       98 |
|  5 | 2019-01-05 |      100 |
|  8 | 2019-01-08 |       92 |
+----+------------+----------+

```

</br>

### 最小的n个数
</br>
[题目]

现在有两个表：

- 学生表里记录了学生的学号、入学时间等信息，字段有：姓名、学号、班级、入学时间、年龄、专业
- 成绩表里记录了学生选课成绩的信息，字段有：学号、课程号、分数
- 两张表通过学号进行连结

现在需要：

- 筛选出2017年入学的"计算机"专业年龄最小的3位同学，输出格式为姓名、年龄
- 统计每个班各位同学成绩平均分大于80分的人数和人数占比



```mysql
#创建学生表

create table stu_07(
    name varchar(64) comment "姓名",
    id int not null comment "学号",
    class varchar(64) comment "班级",
    entrancedate date comment "入学时间",
    age int comment "年龄",
    professional varchar(64) comment "专业");


#查看表
desc stu_07;
+--------------+-------------+------+-----+---------+-------+
| Field        | Type        | Null | Key | Default | Extra |
+--------------+-------------+------+-----+---------+-------+
| name         | varchar(64) | YES  |     | NULL    |       |
| id           | int(11)     | NO   |     | NULL    |       |
| class        | varchar(64) | YES  |     | NULL    |       |
| entrancedate | date        | YES  |     | NULL    |       |
| age          | int(11)     | YES  |     | NULL    |       |
| professional | varchar(64) | YES  |     | NULL    |       |
+--------------+-------------+------+-----+---------+-------+

#插入数据
insert into stu_07(name,id,class,entrancedate,age,professional) 
values 
("赵一",0001,"1班","2016-09-01",19,"计算机"),
("钱二",0002,"1班","2017-09-01",21,"计算机"),
("孙三",0003,"2班","2017-09-01",19,"金融"),
("李四",0004,"3班","2017-09-01",17,"计算机"),
("周周",0005,"3班","2017-09-01",20,"计算机"),
("吴五",0006,"3班","2017-09-01",18,"计算机");

#查看数据
select * from stu_07;
+--------+----+-------+--------------+------+--------------+
| name   | id | class | entrancedate | age  | professional |
+--------+----+-------+--------------+------+--------------+
| 赵一   |  1 | 1班   | 2016-09-01   |   19 | 计算机       |
| 钱二   |  2 | 1班   | 2017-09-01   |   21 | 计算机       |
| 孙三   |  3 | 2班   | 2017-09-01   |   19 | 金融         |
| 李四   |  4 | 3班   | 2017-09-01   |   17 | 计算机       |
| 周周   |  5 | 3班   | 2017-09-01   |   20 | 计算机       |
| 吴五   |  6 | 3班   | 2017-09-01   |   18 | 计算机       |
+--------+----+-------+--------------+------+--------------+

#创建成绩表

create table score_07(id int not null comment "学号",courseid int comment "课程号",score int comment "分数");

#查看表
desc score_07;
+----------+---------+------+-----+---------+-------+
| Field    | Type    | Null | Key | Default | Extra |
+----------+---------+------+-----+---------+-------+
| id       | int(11) | NO   |     | NULL    |       |
| courseid | int(11) | YES  |     | NULL    |       |
| score    | int(11) | YES  |     | NULL    |       |
+----------+---------+------+-----+---------+-------+

#插入数据
insert into score_07(id,courseid,score) 
values
(0001,01,90),
(0002,01,70),
(0002,02,84),
(0003,01,90),
(0003,03,80),
(0004,01,90),
(0004,02,60),
(0005,01,85),
(0006,02,70);

#查看数据
select * from score_07;
+----+----------+-------+
| id | courseid | score |
+----+----------+-------+
|  1 |        1 |    90 |
|  2 |        1 |    70 |
|  2 |        2 |    84 |
|  3 |        1 |    90 |
|  3 |        3 |    80 |
|  4 |        1 |    90 |
|  4 |        2 |    60 |
|  5 |        1 |    85 |
|  6 |        2 |    70 |
+----+----------+-------+
```
</br>

**[解题1]**

- 读题：筛选出**2017年入学**的"**计算机**"专业**年龄最小**的**3位**同学，输出格式为**姓名、年龄**
- 解题：
  - 限定条件1：2017年入学，根据入学时间的年份进行限定
  - 限定条件2：专业 - 计算机
  - 限定条件3：年龄最小的3位同学，根据年龄进行倒序排列，limit输出前3行

```mysql
select name,age
from stu_07
where year(entrancedate) = 2017
and professional = "计算机"
order by age
limit 3;

+--------+------+
| name   | age  |
+--------+------+
| 李四   |   17 |
| 吴五   |   18 |
| 周周   |   20 |
+--------+------+
```
</br>

**[解题2]**

- 读题：统计**每个班**各位同学**成绩平均分**大于**80**分的**人数**和**人数占比**
- 解题：
  - 每位同学成绩平均分 > 80，成绩表根据 id 进行分组算出平均分，作为临时表
  - 统计每个班，则需要按照班级来分组，班级信息在学生表，而平均分信息在临时表，需要两表进行join
  - 输出为人数、人数占比，使用case when 进行统计平均分大于80的人数，以及后续的计算占比

```mysql
select 
sum(case when 平均成绩 > 80 then 1 else 0 end) as "人数",
sum(case when 平均成绩 > 80 then 1 else 0 end)/count(st.id) as "人数占比"
from stu_07 as st 
left join
(select id,avg(score) as 平均成绩 from score_07 group by id) 
as a 
on st.id = a.id
group by st.class;

+--------+--------------+
| 人数   | 人数占比     |
+--------+--------------+
|      1 |       0.5000 |
|      1 |       1.0000 |
|      1 |       0.3333 |
+--------+--------------+
```

</br>

### 连续出现n次的数据
</br>

**[题目]**

成绩表记录了学生id以及分数，字段有：id、score

先需要查找出所有至少连续出现3次的分数

```mysql
#创建表
create table score_09(
    id int not null comment "学号",
    score int comment "分数"
);

#查看表
desc score_09;                                                                           +-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| id    | int(11) | NO   |     | NULL    |       |
| score | int(11) | YES  |     | NULL    |       |
+-------+---------+------+-----+---------+-------+

#插入数据
insert into score_09(id,score) values
(0001,89),(0002,76),(0003,76),
(0004,83),(0005,83),(0006,83),
(0007,77),(0008,90),(0009,88),
(0010,86);

#查看数据
select * from score_09;
+----+-------+
| id | score |
+----+-------+
|  1 |    89 |
|  2 |    76 |
|  3 |    76 |
|  4 |    83 |
|  5 |    83 |
|  6 |    83 |
|  7 |    77 |
|  8 |    90 |
|  9 |    88 |
| 10 |    86 |
+----+-------+
```

</br>

**[思路]**：

- 读题：查找出**所有**、**至少**、**连续出现3次**的分数
- 解题：
  - **注意：这个题目要求学号必须连续，以下语句才能正确执行**
  - 比较同一个表里的同一列的不同行的数据，需要自join
  - 连续出现3次，意思就是学号a的成绩=学号a+1的成绩=学号a+2的成绩，说明需要自join3次
  - 输出为这个至少出现3次的成绩是多少，distinct去除重复

```mysql
select distinct a.score
from score_09 as a join score_09 as b join score_09 as c
on a.id = b.id - 1 and b.id = c.id - 1
where a.score = b.score and b.score = c.score;

+-------+
| score |
+-------+
|    83 |
+-------+
```
</br>


**持续更新中～**





